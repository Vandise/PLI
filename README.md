# Programming Language Implementations
Automating our build process with Make

## Crash-Course
This is a crash course on how to create a Makefile.

### Variables
Variable can be declared various ways. For example, utilizing

```Makefile
MY_VARIABLE ?= some_value
```

will assign a variable a value only if it hasn't been set yet. We can also pass in values by setting environment values when running the make command. 

```bash
MY_VARIABLE=test make all
```

If you want to override possible passed in values, you can assign a variable with simply

```Makefile
MY_VARIABLE = some_value
```

### Functions
Function calls are called by prepending a function name and arguments, enclosed in ` ( ) `, with a `$`. 

For example, if we had a list of file names without an extensions, we can add them by using the `addsuffix` function.

```Makefile
SOBJ =  parser lexer
FILES = $(addsuffix .cpp, $(SOBJ))

#=> FILE = parser.cpp lexer.cpp
``` 

### Rules

```Makefile
target … : prerequisites …
        recipe
        …
        …
```

A target is usually the name of a file that is generated by a program; examples of targets are executable or object files. A target can also be the name of an action to carry out, such as ‘clean’.

A prerequisite is a file that is used as input to create the target. A target often depends on several files.

A recipe is an action that make carries out. A recipe may have more than one command, either on the same line or each on its own line. Please note: you need to put a tab character at the beginning of every recipe line! This is an obscurity that catches the unwary. If you prefer to prefix your recipes with a character other than tab, you can set the .RECIPEPREFIX variable to an alternate character.

Usually a recipe is in a rule with prerequisites and serves to create a target file if any of the prerequisites change. However, the rule that specifies a recipe for the target need not have prerequisites. For example, the rule containing the delete command associated with the target ‘clean’ does not have prerequisites.

A rule, then, explains how and when to remake certain files which are the targets of the particular rule. make carries out the recipe on the prerequisites to create or update the target. A rule can also explain how and when to carry out an action.

A makefile may contain other text besides rules, but a simple makefile need only contain rules. Rules may look somewhat more complicated than shown in this template, but all fit the pattern more or less.

An example rule for deleting a bunch of files (named clear) would look like this below:

```Makefile
CLEANLIST =  $(addsuffix .o, $(OBJ)) $(OBJS) \
				 parser.tab.cc parser.tab.hh \
				 location.hh position.hh \
			    stack.hh parser.output parser.o \
				 lexer.o lexer.yy.cc lex.yy.cpp $(EXE)\

.PHONY: clean
clean:
	rm -rf $(CLEANLIST)
```

## Automating Our Build
Over the past couple tutorials, we've run commands for flex, bison, and to compile our application together. This can get tedious and make it difficult to recall all of the commands. Creating a Makefile will resolve this issue. To start, create a file called `Makefile`. No extensions and it is case-sensitive.

The first thing we'll want is to specify which C++ compiler we'll want to use. For generics, we'll also specify a C compiler. Some other variables include the executable name we'll want to create, compiler flags, and include paths.

```Makefile
CC    ?= clang
CXX   ?= clang++

EXE = my_program

CDEBUG = -g -Wall
CXXDEBUG = -g -Wall

CSTD = -std=c99
CXXSTD = -std=c++11 -I/usr/local/opt/flex/include

CFLAGS = -Wno-deprecated-register -O0  $(CDEBUG) $(CSTD) 
CXXFLAGS = -Wno-deprecated-register -O0  $(CXXDEBUG) $(CXXSTD)
```

NOTE: your include flag for the flex header may be in the util directory. You may have to change this line:
```
CXXSTD = -std=c++11 -I/usr/local/opt/flex/include
```

All we specified were some debug flags, suppress some compiler warnings, and include our FlexLexer header.

Next we need specify all the files we want to pass into our compile command. These files include the main, parser, and lexer cpp files. For simplicity, we're going to use the `addsuffix` function to all our cpp objects to include the extension.

```Makefile

CPPOBJ = main
SOBJ =  parser lexer

FILES = $(addsuffix .cpp, $(CPPOBJ))
OBJS  = $(addsuffix .o, $(CPPOBJ))

```

Now we can specify a "clean list". These are generated files, object files, and old executables that are not part of the application we created.

```Makefile

CLEANLIST =  $(addsuffix .o, $(OBJ)) $(OBJS) \
				 parser.tab.cc parser.tab.hh \
				 location.hh position.hh \
			    stack.hh parser.output parser.o \
				 lexer.o lexer.yy.cc lex.yy.cpp $(EXE)\
```

We also want to specify some default behavior when we run the `make` command. This is the `all` task by default, we can map the default task to one of our tasks. Let's call our task "wc" for word counter.

```Makefile
.PHONY: all
all: wc

wc: $(FILES)
	$(MAKE) $(SOBJ)
	$(MAKE) $(OBJS)
	$(CXX) $(CXXFLAGS) -o $(EXE) $(OBJS) parser.o lexer.o $(LIBS)
```


Our wc task will compile all of our cpp objects and run various tasks specified in the variables `SOBJ`. These are our commands we run to generate our lexer and parser.

```Makefile

.PHONY: all
all: wc

wc: $(FILES)
	$(MAKE) $(SOBJ)
	$(MAKE) $(OBJS)
	$(CXX) $(CXXFLAGS) -o $(EXE) $(OBJS) parser.o lexer.o $(LIBS)

parser: parser.yy
	bison -d -v parser.yy
	$(CXX) $(CXXFLAGS) -c -o parser.o parser.tab.cc

lexer: grammar.l
	flex --outfile=lexer.yy.cc  $<
	$(CXX)  $(CXXFLAGS) -c lexer.yy.cc -o lexer.o

```

Our last command is to remove all of the generated files that we didn't specifically create.

```Makefile

.PHONY: clean
clean:
	rm -rf $(CLEANLIST)

```

## Finished Makefile

```Makefile

CC    ?= clang
CXX   ?= clang++

EXE = my_program

CDEBUG = -g -Wall

CXXDEBUG = -g -Wall

CSTD = -std=c99
CXXSTD = -std=c++11 -I/usr/local/opt/flex/include

CFLAGS = -Wno-deprecated-register -O0  $(CDEBUG) $(CSTD) 
CXXFLAGS = -Wno-deprecated-register -O0  $(CXXDEBUG) $(CXXSTD)


CPPOBJ = main
SOBJ =  parser lexer

FILES = $(addsuffix .cpp, $(CPPOBJ))

OBJS  = $(addsuffix .o, $(CPPOBJ))

CLEANLIST =  $(addsuffix .o, $(OBJ)) $(OBJS) \
				 parser.tab.cc parser.tab.hh \
				 location.hh position.hh \
			    stack.hh parser.output parser.o \
				 lexer.o lexer.yy.cc lex.yy.cpp $(EXE)\

.PHONY: all
all: wc

wc: $(FILES)
	$(MAKE) $(SOBJ)
	$(MAKE) $(OBJS)
	$(CXX) $(CXXFLAGS) -o $(EXE) $(OBJS) parser.o lexer.o $(LIBS)


parser: parser.yy
	bison -d -v parser.yy
	$(CXX) $(CXXFLAGS) -c -o parser.o parser.tab.cc

lexer: grammar.l
	flex --outfile=lexer.yy.cc  $<
	$(CXX)  $(CXXFLAGS) -c lexer.yy.cc -o lexer.o

.PHONY: clean
clean:
	rm -rf $(CLEANLIST)

```

## Copyrights
Benjamin J. Anderson - 2017
